# VueRouter原理分析

1. 对VueRouter的了解
   1. 他是一个Vue的插件库(Vue.use)
   2. 它可以实现SPA应用(单页面应用),单页面->单个html文件
      1. 单页面应用就是通过原生DOM的CRUD方法对单个html页面进行处理,展示出不同效果
         1. ​
2. VueRouter会给我们提供什么?
   1. 构造函数
      1. VueRouter
      2. 通过该构造函数调用,可以生成路由器实例对象,帮助我们管理路由
   2. 组件
      1. router-view
         1. 相当于是组件的占位符,当路由地址匹配的时候,将需要显示的路由组件,显示在当前位置上
      2. router-link
         1. 默认会自动生成a标签
         2. 该方法实现路由跳转,我们俗称声明式导航
         3. 通过标签的形式引导用户进行跳转
         4. 必传标签属性:to
            1. 用于告知VueRouter点击之后跳转到哪个路由地址
   3. 核心对象
      1. $router
         1. 该对象主要提供与控制路由跳转相关的API,例如push,replace,go,back等
         2. push(路径)
            1. 使用该方法可以控制浏览器进行路由跳转,并且保留上个路由记录
            2. 通过js代码控制用户进行路由跳转,该类方法俗称编程式导航
            3. 原生中通过window.location.href也可以实现相应的编程式导航效果,但是与当前VueRouter的区别就在,push方法跳转的时候不会导致浏览器重新请求资源
         3. replace(路径)
            1. 使用该方法可以控制浏览器进行路由跳转,并且覆盖上个路由记录
      2. $route
         1. 该对象主要提供与当前路由相关的信息,例如meta,params,query,path等
3. VueRouter需要我们提供什么?
   1. 配置对象
      1. mode属性
         1. 可以指定当前前端路由的形式,例如:hash,history
         2. hash模式
            1. 优点:
               1. 兼容性好,兼容IE6
               2. 即便刷新浏览器,也不会出现404报错,服务器也不需要做任何的配置处理
                  1. 因为无论hash模式的前端路由是什么,浏览器都会认为是锚点,不会发送给服务器解析
            2. 缺点:
               1. 导致锚点功能失效
               2. 长得太丑了,地址栏中自带#
            3. 原理:
               1. **如何控制浏览器历史记录栈的变化**
                  1. **通过window.location.hash="路由地址"可以控制浏览器地址栏的变化(操作浏览器历史记录栈的变化),同时还能防止浏览器刷新**
               2. **如何监视路由路径的变化**
                  1. **通过window的hashchange事件,可以监视到路由路径的变化**
         3. history模式
            1. 优点:颜值就是正义
            2. 缺点:
               1. 兼容性较差,兼容IE9
               2. **刷新浏览器,会导致页面404报错**
                  1. **流程:**
                     1. **假设当前路由地址为/home,同时使用刷新按钮或者地址栏回车**
                     2. **此时浏览器会将/home误以为是后端路由,从而发送请求给后端**
                        1. **请求地址:https://www.baidu.com/about**
                     3. **服务器接收到来自浏览器的请求,并获得请求的路由地址/home**
                     4. **此时服务器在自身身上查找接口/home,最终并未找到**
                     5. **最后服务器返回404报错**
                     6. **总结:这个问题出现是因为浏览器误将前端路由当作后端路由发送给服务器**
                  2. **解决:**
                     1. **服务器将自己没有的接口统一返回index.html文件**
            3. 原理:
               1. **如何控制浏览器历史记录栈的变化**
                  1. **通过window.history.pushState({},"""路由地址")可以控制浏览器地址栏的变化(操作浏览器历史记录栈的变化),同时还能防止浏览器刷新**
               2. **如何监视路由路径的变化**
                  1. **通过window的popstate事件,可以监视到路由路径的变化**
                  2. **注意:该事件只能监视到前进后退按钮对历史记录栈的操作,无法监视pushState的操作**
      2. routes属性
         1. 数据类型:routeObj[]
         2. 每个路由对象必要属性:
            1. path
               1. 用于与地址栏中的路由地址进行比较
            2. component
               1. 如果浏览器地址栏中的地址与对应的path匹配,页面就会自动显示当前的component

