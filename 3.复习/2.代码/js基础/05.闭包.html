<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
            1.闭包的产生条件
                内部函数使用到外部函数的变量
                    -必须具有两个函数之间的嵌套关系
                    -内部函数必须用到外部的变量
                
                注意:产生闭包并不需要返回内部函数
                闭包分为两种:
                    有效闭包    ->返回内部函数,并且外部接收该函数,该闭包就是有效闭包
                    无效闭包    ->即便不返回内部函数,但是这个闭包也出现过,只是没有意义

            2.闭包的产生时间
                外部函数被调用时
                执行内部函数定义

            3.闭包的优点
                延长了局部变量的生命周期
                    本来当前外层函数执行结束的时候,会销毁执行上下文
                    本来存储于外层函数的变量本该死亡,但是被闭包救了
                模块化(可以保证内部数据的安全性)

            4.闭包的缺点
                可能出现的现象:内存泄漏 
                导致的结果:内存溢出(程序宕机)

            5.如何解决闭包的副作用?
                1.将无用的闭包释放掉即可
                    为什么闭包会存活?
                        因为垃圾回收机制只会回收没人引用的数据
                        由于闭包被内部函数使用,内部函数又被返回到外层作用域,并保存着
                            所以内部函数没死,闭包就不会死

                2.尽量少使用闭包
            
            6.闭包是什么?
                闭包应该是一个对象,他可以存储内部函数使用到的变量
                闭包就是意外存活的变量对象
            
            7.在哪里使用过闭包?
                函数节流,防抖
                函数柯里化
                自己提前想好



            执行上下文:
                每次调用函数都会得到一个全新的执行上下文

                他内部分为两片区域:
                    1.执行当前函数所需要的内存空间
                    2.执行当前函数生成的变量对象
                        变量对象可以收集当前作用域中所有的变量以及数据

                创建时间:
                    函数被调用的时候
                销毁时间:
                    函数执行结束的时候
                    销毁意味着当前本轮执行的所有内容都会销毁


            垃圾回收机制:
                基本数据类型,基本不需要垃圾回收机制管理,他基本都会被覆盖或者伴随死亡
                如果一个对象没有任何的标识引用,那么该对象就会被销毁

                早期版本:引用次数标记
                现在版本:
                    从根节点开始,不断向内递归,遍历所以可以看到的对象
                    分区为两种:新生代区,老生代区
                        新生代区:该数组中存储的新创建的对象
                        老生代区:该数组中存储创建时间比较久的对象

                        新生代区:
                            分为两个数组from,to
                            此处特点:使用空间换时间
                        老生代区:
                            如果在to数组中出现过多次还存活的对象,就是会升级,被提出来放入老生代区
                            此处特点:使用时间换空间
                            
            参考地址:https://blog.csdn.net/shmnh/article/details/50910179

        */

        function a(){
            var num = 2;
            // var b=function (){
            //     console.log(num)
            // }
            function b1(){
                num++;
                console.log(num)
            }
            function b2(){
                num+=2;
                console.log(num)
            }
            return {
                b1,
                b2
            };
        }
        var {b1,b2}=a();
        // var c = b1;
        // b1=null;
        
        b1();
        b1();
        b1();
        b1();
        
        b1=null;

        b2();
        b2();
        b2();
        b2();

        // b1();//3    //3
        // b1();//4    //4
        // b1();//5    //5
        // b1();//6    //6

        // b2();//4    //8
        // b2();//6    //10
        // b2();//8    //12
        // b2();//10   //14


        // function a(){
        //     var num = 2;
        //     console.log(num)
        //     num++;
        // }
        // a();
        // a();

        // (function(){
        //     var a=1;
        //     function getA(){
        //         return a;
        //     }
        //     function addA(){
        //         a++;
        //     }
        //     window.fn={
        //         getA,
        //         addA
        //     }
        // })();
        // fn.addA();
        // console.log(fn.getA())
    </script>
</body>
</html>