# 组件懒加载

1. 前言
   1. 普通Vue项目通过npm run build 打包生成生产环境代码,最终文件夹中具有的文件
      1. index.html
      2. index.js
      3. 说明:这个index.js中具有整个项目所有代码
   2. 举例:假如现在项目中具有10个组件,每个组件代码大小1MB,也就是说项目总体积大约为10MB
      1. 大多数代码都在index.js中,此时index.js的体积应该在10MB左右
      2. 请求项目流程:
         1. 输入url之后,请求对应服务器的index.html文件
         2. 浏览器发现index.html文件中具有script标签,于是再次请求服务器获取index.js文件
         3. 解析index.js文件,通过原生DOM增删改查方法,使得页面渲染出对应组件结果
      3. 此时用户有可能只看其中的home页面,其余9个组件代码白请求了,**浪费带宽,请求文件时间更久,解析时间更久,导致页面白屏时间延长**
   3. ES6模块化
      1. 静态引入
         1. 语法:import ... from '路径'
         2. 用处:将某个文件的代码引入到其余文件中,但是编译为生产环境代码时,该代码会被替换成对应文件代码(最终会导致所有的文件都出现在一个文件中index.js)
      2. 动态引入
         1. 语法:import('路径')
         2. 用处:将某个文件的代码进行引入,但是与静态引入不同,webpack遇到当前引入代码,他不会将对应文件代码复制过来,他会将被引入的文件单独拆分为一个文件,import关键字在上线之后依旧存在
         3. 此时,index.js就不存在被import函数引入的文件代码
2. 组件懒加载
   1. 将index.js中,首屏不需要使用到的9个组件提前拆分出去,减小index.js的体积(此时index.js中只剩下home页面的代码,所以体积为1MB),由于体积变小,所以**请求文件速度变快,浏览器解析js时间减少,最终导致用户白屏时间减少**
   2. **优点:由于index.js体积变小,请求文件速度变快,浏览器解析js时间减少,最终导致用户首屏白屏时间减少**
   3. **缺点:由于index.js中没有其余组件的代码,所以当用户切换组件显示的时候,需要重新发送请求,找服务器获取对应组件的代码文件,再重新解析,最终导致用户后续页面白屏时间变长**
3. 组件预加载
   1. 趁用户不注意的时候(或者可以理解为当前CPU空闲),此时偷偷请求后续可能使用到的服务器资源
   2. **优点:可以解决组件懒加载的缺点,可以提前将后续需要的组件请求到浏览器内存中存放,当用户跳转新的组件时,直接从内存中读取对应组件文件,不需要临时发送http请求获取文件,较少后续页面白屏时间**
   3. **缺点:比较浪费流量**

