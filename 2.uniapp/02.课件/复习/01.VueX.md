# VueX

1. 你对VueX的理解
   1. 他是Vue的一个插件库(需要使用Vue.use)
   2. 用于管理多组件之间的共享状态
2. 核心概念
   1. store
      1. 用处:管理state,mutation,action和getter,并同时向外暴露操作store的API
   2. state
      1. 用处:存储多组件之间的共享状态
   3. mutation
      1. 数据类型:函数
      2. 用处:用于直接修改state的数据
      3. 面试题:mutation为什么必须是同步函数?
         1. 这是官方语法规范
         2. Vue devtools只会记录触发过的mutation,不会记录触发的action函数,最终会导致开发者无法追踪state数据的变化,调试工具失效
      4. 面试题:为什么mutation的名字需要使用常量定义?
         1. 便于协同开发,防止后者创建的mutation覆盖前者重名的mutation,导致报错发生,排错极难
   4. action
      1. 数据类型:函数
      2. 用处:用于间接修改state的数据
      3. 面试题:请问仅从技术上来说,action能否直接修改state数据?
         1. 能
      4. 面试题:那么为什么不用action直接修改state,反而必须使用mutation修改?
         1. 这是官方语法规范
         2. Vue devtools只会记录触发过的mutation,不会记录触发的action函数,最终会导致开发者无法追踪state数据的变化,调试工具失效
   5. getter
      1. 数据类型:函数
      2. 用处:根据state中的数据动态计算结果,同时监视使用到的state数据的变化(类似于Vue组件中的computed)
      3. 面试题:请说说watch和computed的理解
         1. 相同点
            1. 都可以监视某个**响应式属性**的变化,到响应式属性发生变化,watch和computed都会重新执行
         2. 不同点
            1. 使用场景
               1. computed
                  1. 当前需要一个数据,可惜手头没有这个数据,但是可以通过data或者props进行计算得到,该情况下会考虑使用computed
                  2. 他在template中不需要调用,可以类似于data的使用方法
                  3. 例如:购物车页面,通过购物列表计算得到商品总数和总价
               2. watch
                  1. 当某个数据发生变化,我需要做一些事情,该情况下会考虑使用watch
                  2. 例如:当路由参数发生变化,路由地址没有变化,需要重新发送请求
               3. 总结:
                  1. computed更注重结果,watch更注重过程
            2. computed可以用于页面显示,watch不行,所以computed具有缓存机制
               1. 只要计算属性所依赖的数据不发生变化,computed会复用之前的计算结果
            3. 执行次数
               1. computed在组件初始化阶段就会执行,watch默认不会,除非设置setimmidate:true
   6. commit
      1. 用处:用于调用指定的mutation函数
   7. dispatch
      1. 用处:用于调用指定的action函数

